"""
Pass 5: Component Vocabulary

Identifies recurring UI components and captures the designer's thinking about them.
Focuses on identification, properties, and rich narratives - NOT full working code.
"""
from typing import Dict, Any, Optional, List
import json
from datetime import datetime
from .base import BasePass, PassRegistry
from app.llm import LLMService, Message, MessageRole, TextContent
from app.dtr.schemas import Pass5ComponentsDTR, ComponentInventoryItem, ComponentProperties
from app.dtr.extractors.figma_parser import parse_figma_components
from app.dtr.extractors import analyze_components_from_image


class Pass5Components(BasePass):
    """
    Pass 5: Component Vocabulary
    
    Uses Figma component extraction + vision analysis to identify components
    and generate rich narratives about the designer's component thinking.
    """
    
    def __init__(self):
        super().__init__()
        self.llm = LLMService()
    
    async def execute(
        self,
        figma_json: Optional[Dict[str, Any]] = None,
        image_bytes: Optional[bytes] = None,
        image_format: str = "png",
        prev_passes: Optional[Dict[str, Any]] = None
    ) -> Pass5ComponentsDTR:
        """
        Execute Pass 5 component extraction.
        
        Strategy:
        1. Extract components from Figma JSON (if available)
        2. Run vision analysis on image (if available)
        3. Merge results (Figma properties + vision narratives)
        4. Generate code hints from properties
        5. Synthesize global narratives
        
        Args:
            figma_json: Optional Figma JSON data
            image_bytes: Optional image data
            image_format: Image format (png, jpg, webp)
            prev_passes: Results from previous passes (Pass 2 & 3 for tokens)
        
        Returns:
            Pass5ComponentsDTR with component inventory and narratives
        """
        self._start_timing()
        
        # We need at least one input
        if figma_json is None and image_bytes is None:
            return self._create_no_components_dtr()
        
        # Scenario A: Figma JSON only
        if figma_json and not image_bytes:
            return await self._extract_from_figma(figma_json, prev_passes)
        
        # Scenario B: Image only
        if image_bytes and not figma_json:
            return await self._extract_from_vision(image_bytes, image_format, prev_passes)
        
        # Scenario C: Both (hybrid - best quality)
        return await self._extract_hybrid(figma_json, image_bytes, image_format, prev_passes)
    
    async def _extract_from_figma(
        self,
        figma_json: Dict[str, Any],
        prev_passes: Optional[Dict[str, Any]]
    ) -> Pass5ComponentsDTR:
        """Extract components from Figma JSON only."""
        print("Extracting components from Figma JSON (code-based)...")
        
        # Parse components
        figma_data = parse_figma_components(figma_json)
        
        if not figma_data.get('has_components'):
            return self._create_no_components_dtr()
        
        # Build inventory with properties from Figma
        inventory = []
        total_variants = 0
        
        for comp_data in figma_data['inventory']:
            comp_type = comp_data['type']
            variants = comp_data.get('variants', ['default'])
            properties_dict = comp_data.get('properties', {})
            
            # Convert properties dict to ComponentProperties objects
            props_objects = {}
            for variant, props in properties_dict.items():
                props_objects[variant] = ComponentProperties(**props)
            
            # Generate code hints from properties
            code_hints = {}
            for variant, props in properties_dict.items():
                code_hints[variant] = self._generate_code_hint(props)
            
            # Create inventory item with empty narratives (will be generated by LLM)
            inventory.append(ComponentInventoryItem(
                type=comp_type,
                variants=variants,
                properties=props_objects,
                code_hints=code_hints,
                narratives={},  # Will be filled by LLM
                source="figma",
                confidence=0.90
            ))
            
            total_variants += len(variants)
        
        # Generate narratives using LLM
        inventory_with_narratives = await self._generate_narratives_from_properties(
            inventory,
            prev_passes
        )
        
        # Generate global narratives
        global_narratives = await self._generate_global_narratives(
            inventory_with_narratives,
            authority="code"
        )
        
        elapsed = self._get_elapsed_time()
        
        return Pass5ComponentsDTR(
            authority="code",
            confidence=0.90,
            component_system_philosophy=global_narratives['system_philosophy'],
            cross_component_patterns=global_narratives['cross_patterns'],
            notable_absences=global_narratives['absences'],
            inventory=inventory_with_narratives,
            total_components=len(inventory_with_narratives),
            total_variants=total_variants
        )
    
    async def _extract_from_vision(
        self,
        image_bytes: bytes,
        image_format: str,
        prev_passes: Optional[Dict[str, Any]]
    ) -> Pass5ComponentsDTR:
        """Extract components from image only (vision analysis)."""
        print("Extracting components from image (vision-based)...")
        
        # Run vision analysis
        vision_data = await analyze_components_from_image(
            image_bytes,
            image_format,
            figma_inventory=None
        )
        
        if not vision_data.get('inventory'):
            return self._create_no_components_dtr()
        
        # Convert vision data to inventory items
        inventory = []
        for comp_data in vision_data['inventory']:
            # Convert properties to ComponentProperties objects
            props_objects = {}
            for variant, props in comp_data.get('properties', {}).items():
                props_objects[variant] = ComponentProperties(**props)
            
            inventory.append(ComponentInventoryItem(
                type=comp_data['type'],
                variants=comp_data.get('variants', ['default']),
                properties=props_objects,
                code_hints=comp_data.get('code_hints', {}),
                narratives=comp_data.get('narratives', {}),
                source="vision",
                confidence=comp_data.get('confidence', 0.75)
            ))
        
        return Pass5ComponentsDTR(
            authority="vision",
            confidence=0.75,
            component_system_philosophy=vision_data.get('component_system_philosophy', ''),
            cross_component_patterns=vision_data.get('cross_component_patterns', ''),
            notable_absences=vision_data.get('notable_absences', ''),
            inventory=inventory,
            total_components=vision_data.get('total_components', len(inventory)),
            total_variants=vision_data.get('total_variants', sum(len(c.variants) for c in inventory))
        )
    
    async def _extract_hybrid(
        self,
        figma_json: Dict[str, Any],
        image_bytes: bytes,
        image_format: str,
        prev_passes: Optional[Dict[str, Any]]
    ) -> Pass5ComponentsDTR:
        """Extract components using both Figma and vision (best quality)."""
        print("Extracting components in hybrid mode (Figma + vision)...")
        
        # 1. Parse Figma components for exact properties
        figma_data = parse_figma_components(figma_json)
        
        # 2. Run vision analysis with Figma context
        vision_data = await analyze_components_from_image(
            image_bytes,
            image_format,
            figma_inventory=figma_data.get('inventory', [])
        )
        
        # 3. Merge: Use Figma properties + vision narratives
        inventory = []
        total_variants = 0
        
        # Build a map of Figma components by type
        figma_by_type = {
            comp['type']: comp
            for comp in figma_data.get('inventory', [])
        }
        
        # Process vision inventory (which includes narratives)
        for vision_comp in vision_data.get('inventory', []):
            comp_type = vision_comp['type']
            
            # Get Figma data for this type if available
            figma_comp = figma_by_type.get(comp_type)
            
            if figma_comp:
                # Use Figma properties (exact) + vision narratives (rich)
                variants = figma_comp.get('variants', ['default'])
                
                # Convert Figma properties to ComponentProperties
                props_objects = {}
                for variant, props in figma_comp.get('properties', {}).items():
                    props_objects[variant] = ComponentProperties(**props)
                
                # Generate code hints from Figma properties
                code_hints = {}
                for variant, props in figma_comp.get('properties', {}).items():
                    code_hints[variant] = self._generate_code_hint(props)
                
                # Use vision narratives
                narratives = vision_comp.get('narratives', {})
                confidence = 0.95  # Highest confidence (hybrid)
                source = "hybrid"
            else:
                # Vision only - no Figma data for this component
                variants = vision_comp.get('variants', ['default'])
                
                # Convert vision properties
                props_objects = {}
                for variant, props in vision_comp.get('properties', {}).items():
                    props_objects[variant] = ComponentProperties(**props)
                
                code_hints = vision_comp.get('code_hints', {})
                narratives = vision_comp.get('narratives', {})
                confidence = 0.75  # Vision only
                source = "vision"
            
            inventory.append(ComponentInventoryItem(
                type=comp_type,
                variants=variants,
                properties=props_objects,
                code_hints=code_hints,
                narratives=narratives,
                source=source,
                confidence=confidence
            ))
            
            total_variants += len(variants)
        
        return Pass5ComponentsDTR(
            authority="hybrid",
            confidence=0.95,
            component_system_philosophy=vision_data.get('component_system_philosophy', ''),
            cross_component_patterns=vision_data.get('cross_component_patterns', ''),
            notable_absences=vision_data.get('notable_absences', ''),
            inventory=inventory,
            total_components=len(inventory),
            total_variants=total_variants
        )
    
    def _generate_code_hint(self, properties: Dict[str, Any]) -> str:
        """Generate Tailwind code hint from properties."""
        classes = []
        
        # Background
        bg = properties.get('background')
        if bg and bg != 'gradient':
            classes.append(f"bg-[{bg}]")
        
        # Text color
        text_color = properties.get('text_color')
        if text_color:
            classes.append(f"text-[{text_color}]")
        
        # Padding
        padding = properties.get('padding')
        if padding:
            # Convert "12px 24px" to "px-6 py-3" (approximate)
            parts = padding.split()
            if len(parts) == 2:
                py = int(parts[0].replace('px', '')) // 4
                px = int(parts[1].replace('px', '')) // 4
                classes.append(f"px-{px} py-{py}")
        
        # Border radius
        radius = properties.get('border_radius')
        if radius:
            px_val = int(radius.replace('px', ''))
            if px_val == 4:
                classes.append("rounded")
            elif px_val == 8:
                classes.append("rounded-lg")
            elif px_val == 12:
                classes.append("rounded-xl")
            else:
                classes.append(f"rounded-[{radius}]")
        
        # Font weight
        weight = properties.get('font_weight')
        if weight:
            if weight >= 700:
                classes.append("font-bold")
            elif weight >= 600:
                classes.append("font-semibold")
            elif weight >= 500:
                classes.append("font-medium")
        
        # Text transform
        transform = properties.get('text_transform')
        if transform == 'uppercase':
            classes.append("uppercase")
        
        # Letter spacing
        spacing = properties.get('letter_spacing')
        if spacing and spacing != 'normal':
            if 'em' in spacing:
                classes.append("tracking-wide")
            else:
                classes.append(f"tracking-[{spacing}]")
        
        # Shadow
        shadow = properties.get('shadow')
        if shadow:
            if 'shadow-lg' in classes or 'shadow-md' in classes:
                pass  # Already added
            else:
                classes.append("shadow-lg")
        
        return " ".join(classes) if classes else ""
    
    async def _generate_narratives_from_properties(
        self,
        inventory: List[ComponentInventoryItem],
        prev_passes: Optional[Dict[str, Any]]
    ) -> List[ComponentInventoryItem]:
        """Generate rich narratives from extracted properties using LLM."""
        print("Generating rich narratives from component properties...")
        
        # Build context from previous passes if available
        context = ""
        if prev_passes:
            pass_2 = prev_passes.get('pass_2_surface')
            pass_3 = prev_passes.get('pass_3_typography')
            
            if pass_2:
                context += f"\nCOLOR PALETTE: Primary accent: {pass_2.get('colors', {}).get('exact_palette', [{}])[0].get('hex', 'N/A') if pass_2.get('colors', {}).get('exact_palette') else 'N/A'}"
            
            if pass_3:
                context += f"\nTYPOGRAPHY: {', '.join([f.get('name', '') for f in pass_3.get('families', [])[:2]])}"
        
        # Build component summary for prompt
        comp_summary = []
        for item in inventory:
            variants_str = ', '.join(item.variants)
            comp_summary.append(f"- {item.type}: {variants_str}")
        
        components_text = '\n'.join(comp_summary)
        
        # Generate narratives via LLM
        prompt = f"""Based on these extracted component properties, generate rich narratives explaining the designer's thinking.

COMPONENTS IDENTIFIED:
{components_text}
{context}

For EACH component, generate 3-4 rich, multi-sentence narratives (choose the most relevant):
- design_thinking: Core philosophy and key design decisions
- variant_system: How variants differ and semantic meaning
- interaction_philosophy: Hover/focus/active state choreography
- usage_patterns: Where/when/how components appear

Return ONLY JSON matching this schema:
{{
  "components": [
    {{
      "type": "button",
      "narratives": {{
        "design_thinking": "Multi-sentence rich description...",
        "variant_system": "Multi-sentence rich description...",
        "interaction_philosophy": "Multi-sentence rich description...",
        "usage_patterns": "Multi-sentence rich description..."
      }}
    }}
  ]
}}

CRITICAL: Return ONLY the JSON object, no markdown, no preamble."""
        
        try:
            response = await self.llm.generate(
                model="claude-sonnet-4.5",
                messages=[
                    Message(role=MessageRole.USER, content=prompt)
                ],
                temperature=0.3,
                max_tokens=3000
            )
            
            # Parse response
            text = response.text.strip()
            
            # Remove markdown if present
            if text.startswith('```'):
                lines = text.split('\n')
                text = '\n'.join(lines[1:-1])
            
            # Extract JSON
            start = text.find('{')
            end = text.rfind('}')
            if start >= 0 and end >= 0:
                json_str = text[start:end+1]
                result = json.loads(json_str)
                
                # Map narratives to inventory items
                narratives_by_type = {
                    comp['type']: comp['narratives']
                    for comp in result.get('components', [])
                }
                
                # Update inventory with narratives
                for item in inventory:
                    if item.type in narratives_by_type:
                        item.narratives = narratives_by_type[item.type]
                
        except Exception as e:
            print(f"Failed to generate narratives: {e}")
            # Continue with empty narratives
        
        return inventory
    
    async def _generate_global_narratives(
        self,
        inventory: List[ComponentInventoryItem],
        authority: str
    ) -> Dict[str, str]:
        """Generate global narratives about the component system."""
        print("Generating global component system narratives...")
        
        # Build summary
        comp_types = [item.type for item in inventory]
        comp_summary = f"{len(inventory)} component types: {', '.join(comp_types)}"
        
        prompt = f"""Based on these components, generate global narratives about the designer's component philosophy.

COMPONENTS: {comp_summary}

Generate 3 global narratives:
1. component_system_philosophy: Multi-paragraph synthesis of how this designer thinks about components as a system
2. cross_component_patterns: How components share visual language (radius, shadows, colors, etc.)
3. notable_absences: What's consistently absent (no pill buttons, no gradients, etc.)

Return ONLY JSON:
{{
  "system_philosophy": "Multi-paragraph text...",
  "cross_patterns": "Rich text...",
  "absences": "Rich text..."
}}"""
        
        try:
            response = await self.llm.generate(
                model="claude-sonnet-4.5",
                messages=[
                    Message(role=MessageRole.USER, content=prompt)
                ],
                temperature=0.3,
                max_tokens=2000
            )
            
            text = response.text.strip()
            if text.startswith('```'):
                lines = text.split('\n')
                text = '\n'.join(lines[1:-1])
            
            start = text.find('{')
            end = text.rfind('}')
            if start >= 0 and end >= 0:
                json_str = text[start:end+1]
                result = json.loads(json_str)
                return {
                    'system_philosophy': result.get('system_philosophy', ''),
                    'cross_patterns': result.get('cross_patterns', ''),
                    'absences': result.get('absences', '')
                }
        except Exception as e:
            print(f"Failed to generate global narratives: {e}")
        
        # Fallback
        return {
            'system_philosophy': f"Component system analysis based on {len(inventory)} identified components.",
            'cross_patterns': "Unable to analyze cross-component patterns.",
            'absences': "Unable to identify notable absences."
        }
    
    def _create_no_components_dtr(self) -> Pass5ComponentsDTR:
        """Create fallback DTR when no components found."""
        return Pass5ComponentsDTR(
            authority="none",
            confidence=0.0,
            component_system_philosophy="No components identified in this design.",
            cross_component_patterns="N/A",
            notable_absences="N/A",
            inventory=[],
            total_components=0,
            total_variants=0
        )


# Register pass
PassRegistry.register("pass_5_components", Pass5Components)


# ============================================================================
# PUBLIC API
# ============================================================================

async def run_pass_5(
    figma_json: Optional[Dict[str, Any]] = None,
    image_bytes: Optional[bytes] = None,
    image_format: str = "png",
    prev_passes: Optional[Dict[str, Any]] = None
) -> Pass5ComponentsDTR:
    """
    Run Pass 5 (Component Vocabulary).
    
    Args:
        figma_json: Optional Figma JSON
        image_bytes: Optional image data
        image_format: Image format
        prev_passes: Results from previous passes
    
    Returns:
        Pass5ComponentsDTR
    """
    pass_instance = Pass5Components()
    return await pass_instance.execute(
        figma_json=figma_json,
        image_bytes=image_bytes,
        image_format=image_format,
        prev_passes=prev_passes
    )